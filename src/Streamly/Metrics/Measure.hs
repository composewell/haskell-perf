module Streamly.Metrics.Measure
    (
      bracketWith
    , bracket
    , tick
    , timestamp
    )
where

import Streamly.Internal.Data.Time.Units (AbsTime)

-------------------------------------------------------------------------------
-- Useful metric generator functions
-------------------------------------------------------------------------------

-- We can create a measurement Monad in which we provide the following
-- commands:
--
-- * start -- start measurement
-- * end -- end measurement
--
-- One or more perf events are generated by "end". Options/config can be
-- provided to "start" (use startWith) for controlling what kind of
-- measurements will be done and what events will be generated. The event will
-- be identified by both start and end ids. We can use end multiple times.

-- | Apply a monadic function to its argument with pre and post action hooks
-- and return a tuple containing the result of the action as well as the result
-- of the post hook.
--
-- The function is exception safe. If an exception occurs the post hook is run
-- and the exception is rethrown.
--
-- Any pure computations that are dependent on @b@ are computed every time.
-- However anything pure that does not depend on @b@ will be precomputed and
-- won't take any time. If you want to measure pure computations make sure all
-- the inputs are supplied dynamically as funciton arguments.
--
{-# INLINE bracketWith #-}
bracketWith :: Monad m => m a -> (a -> m d) -> (b -> m c) -> b -> m (c, d)
bracketWith pre post func arg = do
    r <- pre
    v <- func arg
    r1 <- post r
    return (v, r1)

-- | Like 'bracketWith' but using an action instead of a function and its
-- argument.
{-# INLINE bracket #-}
bracket :: Monad m => m a -> (a -> m d) -> m c -> m (c, d)
bracket pre post action = bracketWith pre post (const action) ()

-- | Return a @()@ value as side effect every time a pure value is used.
{-# INLINE tick #-}
tick :: Monad m => a -> m (a, ())
tick a = bracket (pure ()) pure (pure a)

-- | Return the current timestamp as a side effect.
timestamp :: a -> m (a, AbsTime)
timestamp = undefined
